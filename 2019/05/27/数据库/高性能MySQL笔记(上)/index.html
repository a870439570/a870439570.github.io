<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">



  <meta name="keywords" content="sql,">





  <link rel="alternate" href="/atom.xml" title="印象博客" type="application/atom+xml">






<meta name="description" content="无论何时，只要有多个查询需要在同一个时刻修改数据时，就会有并发问题。MySql主要在服务器层与存储引擎层进行并发控制。  假设数据库中国一张邮箱表，每个邮件都是一条记录。如果某个客户正在读取邮箱，同时其他客户试图在删除邮箱表中的某一条数据。这个时候，读取的结构就是不确定的了。在MySql中会通过锁定防止其它用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。   MySQL锁的粒">
<meta name="keywords" content="sql">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能MySQL第三本笔记总结（上）">
<meta property="og:url" content="https://qinxuewu.github.io/2019/05/27/数据库/高性能MySQL笔记(上)/index.html">
<meta property="og:site_name" content="印象博客">
<meta property="og:description" content="无论何时，只要有多个查询需要在同一个时刻修改数据时，就会有并发问题。MySql主要在服务器层与存储引擎层进行并发控制。  假设数据库中国一张邮箱表，每个邮件都是一条记录。如果某个客户正在读取邮箱，同时其他客户试图在删除邮箱表中的某一条数据。这个时候，读取的结构就是不确定的了。在MySql中会通过锁定防止其它用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。   MySQL锁的粒">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190428211616178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-09-02T09:39:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高性能MySQL第三本笔记总结（上）">
<meta name="twitter:description" content="无论何时，只要有多个查询需要在同一个时刻修改数据时，就会有并发问题。MySql主要在服务器层与存储引擎层进行并发控制。  假设数据库中国一张邮箱表，每个邮件都是一条记录。如果某个客户正在读取邮箱，同时其他客户试图在删除邮箱表中的某一条数据。这个时候，读取的结构就是不确定的了。在MySql中会通过锁定防止其它用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。   MySQL锁的粒">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190428211616178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://qinxuewu.github.io/2019/05/27/数据库/高性能MySQL笔记(上)/">





  <title>高性能MySQL第三本笔记总结（上） | 印象博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?96c30928a2ca92d1a2dce136bde0ab81";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">印象博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-工具">
          <a href="/Brain/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            工具
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://qinxuewu.github.io/2019/05/27/数据库/高性能MySQL笔记(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qinxuewu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo_qinxuewu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="印象博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">高性能MySQL第三本笔记总结（上）</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-27T15:43:11+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><p><img src="https://img-blog.csdnimg.cn/20190428211616178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70" alt="SQL语句的执行流程"></p>
<blockquote>
<p>无论何时，只要有多个查询需要在同一个时刻修改数据时，就会有并发问题。MySql主要在<code>服务器层</code>与<code>存储引擎层</code>进行并发控制。</p>
</blockquote>
<p>假设数据库中国一张邮箱表，每个邮件都是一条记录。如果某个客户正在读取邮箱，同时其他客户试图在删除邮箱表中的某一条数据。这个时候，读取的结构就是不确定的了。在MySql中会通过锁定防止其它用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。</p>
</li>
</ul>
<h2 id="MySQL锁的粒度"><a href="#MySQL锁的粒度" class="headerlink" title="MySQL锁的粒度"></a>MySQL锁的粒度</h2><ul>
<li>每种MySql引擎都可以实现自己的锁策略和锁粒度，将锁粒度固定在某个级别，可以为某些特定的场景提供更好的性能。</li>
</ul>
<h3 id="表锁-table-lock"><a href="#表锁-table-lock" class="headerlink" title="表锁(table lock)"></a>表锁(table lock)</h3><ul>
<li>表锁是mysql中最基本的锁略，并且是开销最小的策略。它会锁定整个表，一个用户在对表进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时,其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。</li>
<li>在特定的场景中，表锁也可能有良好的性能。例如，<code>READ L0CAL</code> 表锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此-一个写锁请求可能会被插入到读锁队列的前面(写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面)。</li>
<li>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如<code>ALTER TABLE</code>之类的语句使用表锁，而忽略存储引擎的锁机制。</li>
</ul>
<h3 id="行级锁-row-lock"><a href="#行级锁-row-lock" class="headerlink" title="行级锁(row lock)"></a>行级锁(row lock)</h3><ul>
<li>行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。</li>
<li>在<code>InnoDB</code>和<code>XtraDB</code>,以及其他一些存储引擎中实现了行级锁。</li>
<li>行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。</li>
</ul>
<h2 id="MySQL的事务"><a href="#MySQL的事务" class="headerlink" title="MySQL的事务"></a>MySQL的事务</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul>
<li>A（原子性）事务的各步操作是不可分的，保证一系列的操作要么都完成，要么都不完成；</li>
<li>C（一致性）事务完成，数据必须处于一致的状态；</li>
<li>I（隔离性）对数据进行修改的所有并发事务彼此之间是相互隔离，这表明事务必须是独立的，不应以任何方式依赖或影响其他事务；</li>
<li>D（持久性）表示事务对数据处理结束后，对数据更改必须持久化，不管是事务成功还是回滚。事务日志都能够保持事务的永久性。</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</li>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交的更改对其他事务是不可见的</li>
<li>串行化:对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行。最高的隔离级别</li>
</ul>
<h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><ul>
<li>MySQL提供了两种事务型的存储引擎: <code>InnoDB</code>和<code>NDB Cluster</code>。另外还有一些第三方存储引擎也支持事</li>
<li>MySQL默认采用自动提交(AUTOCOMIT) 模式。如果不是显式地开始-一个个事务，则每个查询都被当作一事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式:</li>
<li>InnoDB采用的是两阶段锁定协议(two-phase locking protocol)。在事务执行过程中，随时都可以执行锁定，锁只有在执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候才会释放，并且所有的锁是在同一时刻被释放。</li>
<li>InnoDB也支持通过特定的语句进行显式锁定<code>SELECT ... LOCK IN SHARE MODE</code>和<code>SELECT FOR UPDATE</code> 些语句不属于SQL规范</li>
</ul>
<h2 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h2><ul>
<li><code>MVCC</code>是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</li>
<li>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同张表，同一时刻看到的数据可能是不一样的。</li>
<li><code>InnoDB</code>的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</li>
<li>MVCC只在可重复读和读提交的隔离级别生效。其它两个级别都不兼容</li>
</ul>
<blockquote>
<p>在可重复读(<code>REPEATABLE READ</code>)隔离级别下，MVCC具体是如何操作的。</p>
</blockquote>
<p> <strong>SELECT查询操作时</strong></p>
<p>InnoDB会根据以下两个条件检查每行记录:</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号),这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
<p><strong>INSERT</strong></p>
<ul>
<li>InnoDB为新播入的每-一行保存当前系统版本号作为行版本号。</li>
</ul>
<p><strong>DELETE</strong></p>
<ul>
<li>InnoDB为删除的每-*行保存当前系统版本号作为行删除标识。</li>
</ul>
<p><strong>UPDATE</strong></p>
<ul>
<li>InnoDB为插入-行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
</ul>
<h2 id="数据库存储引擎"><a href="#数据库存储引擎" class="headerlink" title="数据库存储引擎"></a>数据库存储引擎</h2><h3 id="InnDB存储引擎"><a href="#InnDB存储引擎" class="headerlink" title="InnDB存储引擎"></a>InnDB存储引擎</h3><ul>
<li>InnDB是Mysql默认的事务型存储引擎。它被设计用来处理大量的短期(short-lived) 事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行</li>
<li>InnoDB的数据存储在表空间(tablespace) 中，表空间是由InnoDB管理的-个黑盒子，由一系列的数据文件组成。</li>
<li>InnoDB采用<code>MVCC</code>来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ (<code>可重复读</code>) ,并且通过<code>间隙锁</code>(next-key locking)策略防止<code>幻读</code>的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</li>
<li>InnoDB表是基于聚簇索引建立的。聚簇素引对主键查询有很高的性能，不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。</li>
<li>InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引(adaptive hash index),以及能够加速插入操作的插入缓冲区(insert buffer)等</li>
</ul>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><ul>
<li><code>MyISAM不支持事务和行锁</code>，在MySQL5.1之前的版本是默认的存储引擎，有一个缺陷是崩溃后无法恢复。</li>
<li>优点是对于只读的数据，或者表比较小，可以忍受修复操作，可以继续使用</li>
<li>MyISAM会将表存储在两个文件中:数据文件和索引文件，分别以.MYD和.MYI为扩展名</li>
<li>MyISAM表可以包含动态或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间,或者操作系统中单个文件的最大尺寸。</li>
<li><code>MyISAM对整张表加锁，而不是针对行</code>。读取时会对需要读到的所有表加共享锁,写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录(这被称为并发插入)</li>
</ul>
<h3 id="Archive引擎"><a href="#Archive引擎" class="headerlink" title="Archive引擎"></a>Archive引擎</h3><ul>
<li>Archive引擎会缓存所有的写并利用zlib对插人的行进行压缩，所以比MyISAM表的磁盘I/O更少。但是每次SELECT查询都需要执行全表扫描。所以Archive表适合日志和数据采集类应用，这类应用做数据分析时往往需要全表扫描。或者在一- 些需要更快速的INSERT操作的场合下也可以使用。</li>
<li><code>Archive引擎</code>支持<code>行级锁和专用的缓冲区</code>，所可以实现高并发的插人。在一个查询开始直到返回表中存在的所有行数之前，Archive引擎会阻止其他的SELECT执行，以实现一致性读。另外，也实现了批量插入在完成之前对读操作是不可见的。这种机制模仿了事务和MVCC的一些特性，但Archive引擎不是一个事务型的引擎，而是-一个针对高速插人和压缩做了优化的简单引擎。</li>
</ul>
<h3 id="Blackhole引擎"><a href="#Blackhole引擎" class="headerlink" title="Blackhole引擎"></a>Blackhole引擎</h3><ul>
<li>Blackhole引擎没有实现任何的存储机制，它会丟弃所有插入的数据，不做任何保存。但是服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。这种特殊的存储引擎可以在–些特殊的复制架构和8志审核时发挥作用。但这种应用方式我们碰到过很多问题，因此并不推荐。</li>
</ul>
<h3 id="CSV引擎"><a href="#CSV引擎" class="headerlink" title="CSV引擎"></a>CSV引擎</h3><ul>
<li>CSV引擎可以将普通的CSV文件(逗号分割值的文件)作为MySQL的表来处理，但这种表不支持索引。CSV引擎可以在数据库运行时拷入或者拷出文件。可以将Excel等电子表格软件中的数据存储为CSV文件，然后复制到MySQL数据目录下，就能在MySQL中打开使用。同样，如果将数据写人到一个CSV引擎表，其他的外部程序也能立即从表的数据文件中读取CSV格式的数据。因此CSV引擎可以作为- -种数据交换的机制，非常有用。</li>
</ul>
<h3 id="Federated引擎"><a href="#Federated引擎" class="headerlink" title="Federated引擎"></a>Federated引擎</h3><ul>
<li>Federated引擎是访问其他MySQL服务器的-一个代理，它会创建-一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。最初设计该存储引擎是为了和企业级数据库如Microsoft SQL Server和Oracle的类似特性竞争的，可以说更多的是一种市场行为。尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ul>
<h3 id="Memory引擎"><a href="#Memory引擎" class="headerlink" title="Memory引擎"></a>Memory引擎</h3><ul>
<li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表(以前也叫做HEAP表)是非常有用的。Memory 表至少比MyISAM表要快一个数量级，因为所有的数据都保存在内存中,不需要进行磁盘I/O。Memory 表的结构在重启以后还会保留,但数据会丢失。</li>
</ul>
<h2 id="Schema-数据库的组织和结构-与数据类型优化"><a href="#Schema-数据库的组织和结构-与数据类型优化" class="headerlink" title="Schema(数据库的组织和结构)与数据类型优化"></a>Schema(数据库的组织和结构)与数据类型优化</h2><h3 id="更小的通常好"><a href="#更小的通常好" class="headerlink" title="更小的通常好"></a>更小的通常好</h3><ul>
<li>尽量使用可以正确存储数据的最下数据类型，更小的数据类型通常更快，占用更小的磁盘,内存和cpu缓存,并且处理时需要的cpu周期更少</li>
<li>但是要确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作。如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型</li>
</ul>
<h3 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h3><ul>
<li>简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，</li>
<li>整型比字符操作代价更低，因为字符集和校对规则(排序规则)使字符比较比整型比较更复杂</li>
<li>使用MySQL内建的类型而不是字符串来存储日期和时间</li>
<li>用整型存储IP地址。int类型占4个字节，tinyint占1个字节。</li>
</ul>
<h3 id="尽量避免NUll"><a href="#尽量避免NUll" class="headerlink" title="尽量避免NUll"></a>尽量避免NUll</h3><ul>
<li>如果查询中包含null的列，会使得索引，索引统计和值比较更复杂</li>
<li>当可以NULL的列被索引时,每个索引记录需要一个额外的字节</li>
</ul>
<h3 id="datetime和timesamp"><a href="#datetime和timesamp" class="headerlink" title="datetime和timesamp"></a>datetime和timesamp</h3><ul>
<li>datetime和timesamp都可以存储相同的数据类型,时间和日期，精确到秒。然而timesamp只使用datetime一半的存储空间</li>
<li>timesamp 会根据时区变化，具有特殊的自动更新能力，允许的时间范围要小很多，有时它的特许能力会成为障碍</li>
</ul>
<h3 id="字段列的类型选择"><a href="#字段列的类型选择" class="headerlink" title="字段列的类型选择"></a>字段列的类型选择</h3><ul>
<li>在满足值的范围情况下，尽量选择最小的数据类型。列如tinyint比int少三个字节。tinyint 1字节 (-128，127) (0，255) 小整数值</li>
<li>字段固定长度如手机号，身份证号用<code>char</code>,可变长度使用<code>varchar</code>因为其长度固定，方便程序的存储与查找,付出的是空间的代价。varchar是以空间效率为首位的</li>
<li>整数类型通常是标识列最好的数据类型，因为他们很快并且可以使<code>AUTO_INCREMENT</code></li>
<li>如果可能，尽量批量使用字符串类型，因为它们消耗更多的空间，比数字类型慢</li>
<li>如果存储UUID值，可以移除-符号。使用<code>UNHEX()</code>函数转换为UUID的16字节的的数字，并存储在一个binary(16)列中。取值时可以使用<code>HEX()</code>格式化为16进制格式</li>
</ul>
<h3 id="使用inet-aton和inet-ntoa处理ip地址数据"><a href="#使用inet-aton和inet-ntoa处理ip地址数据" class="headerlink" title="使用inet_aton和inet_ntoa处理ip地址数据"></a>使用inet_aton和inet_ntoa处理ip地址数据</h3><ul>
<li>插入数据前，先用<code>inet_aton</code>把ip地址转为整型，可以节省空间，因为<code>char(15)</code> 占16字节。 </li>
<li>显示数据时，使用<code>inet_ntoa</code>把整型的ip地址转为电地址显示即可。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>尽量避免过度设计，例如会导致极其复杂査询的schema设计，或者有很多列的表设计</li>
<li>使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值。</li>
<li>尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。</li>
<li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。</li>
<li>尽量使用整型定义标识列。</li>
<li>避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。</li>
<li>小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成 陷阱。最好避免使用BIT。</li>
<li>ALTER TABLE是让人痛苦的操作，因为在大部分情况下，它都会锁表并且重建整张表。例如在备机执行ALTER并在完成后把它切换为主库。</li>
</ul>
<h2 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h2><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><ul>
<li>索引有很多类型,Mysql是使用<code>B+tree</code>树索引,索引是在引擎层实现而不是服务层。不同引擎的索引工作方式不一样。</li>
<li><code>MyISAM</code>使用前缀压缩技术使得索引更小，<code>InnoDB</code>按照原数据根式进行存储。<code>MyISAM</code>索引通过数据到物理位置引用被索引的行，<code>InnoDB</code>根据主键引用被索引的行</li>
<li>全值匹配：指的是和索引中所有列进行匹配。比如<code>EXPLAIN</code> 中的type=index</li>
<li>最左匹配原则: mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。也就是如果使用复合索引查询时优先按照索引创建的顺序进行条件查询</li>
</ul>
<h3 id="索引的选择策略"><a href="#索引的选择策略" class="headerlink" title="索引的选择策略"></a>索引的选择策略</h3><ul>
<li>索引字段必须是独立的列，不嗯呢该是表达式和函数运算</li>
<li>计算合适的前缀索引长度</li>
<li>善用复合索引，而不是为每个字段都建立索引，选择合适的索引列顺序</li>
<li>当不需要排序和分组时使用频率较高的放在复合索引前列,这时候的索引优化用于where条件</li>
<li>尽可能将左范围查询的列放在索引的后面,以便优化器使用尽可能多的索引列。</li>
<li>对于范围条件查询,mysql范围列后面的其它的索引列,对于多个等值条件查询则没有这种限制</li>
</ul>
<h3 id="Inndb主键索引和非主键索引的区别"><a href="#Inndb主键索引和非主键索引的区别" class="headerlink" title="Inndb主键索引和非主键索引的区别"></a>Inndb主键索引和非主键索引的区别</h3><ul>
<li>主键索引即存储了索引值，又在叶子中存储了行的数据。所以通过主键查询时效率高，一次查询即可，不需要回表操作。这种即存储索引值又存储行的所有数据的结构叫做(聚簇索引）</li>
<li>非主键索引存储索引值，但叶子中存储的是主键ID，所以查询时需要进行一次回表操作才可以取到所有的行数据</li>
</ul>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><ul>
<li>索引覆盖是指如果查询的列恰好是索引的一部分,那么查询只需要在索引文件上进行,不需要回行到磁盘再找数据.这种查询速度非常快,称为”索引覆盖”</li>
</ul>
<h3 id="理想的索引"><a href="#理想的索引" class="headerlink" title="理想的索引"></a>理想的索引</h3><ul>
<li>理想的索引。1:查询频繁 2:区分度高 3:长度小 4:尽量能覆盖常用查询字段.</li>
<li>索引长度直接影响索引文件的大小,影响增删改的速度,并间接影响查询速度(占用内存多).</li>
<li>针对列中的值,从左往右截取部分,来建索引</li>
<li>截的越短,重复度越高,区分度越小, 索引效果越不好</li>
<li>截的越长,重复度越低,区分度越高,索引效果越好,但带来的影响也越大–增删改变慢,并间影响查询速度.所以,我们要在  区分度+长度，两者上,取得一个平衡.</li>
<li>惯用手法:截取不同长度,并测试其区分度</li>
</ul>
<blockquote>
<p>select count(distinct left(word,6))/count(*) from dict;</p>
</blockquote>
<h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><ul>
<li>mysql有两种方式可以生成有序的结果：通过排序操作或者按索引顺序扫描。如果explan出来的type值为<code>index</code>则说明使用了索引扫描来做排序。</li>
<li>只有索引列的顺序和<code>order by</code>字段的顺序完全一致，并且所有列的排序方向都一样时,mysql才能使用索引对结果进行排序。</li>
<li>如果查询需要关联多表，则只有当order by中使用的字段完全是第一个表时，才能使用索引做排序。order by和查找型的限制一样，都要满足最左前缀要求。</li>
<li>如果索引的第一个字段为常量时，where或join中指对这个列制定了固定的常量值，就可以不满足最左前缀要求。比如有个复合索引<code>(c1,c2,c3)</code>, 执行 <code>select * from where c1=1 order c2,c3</code> 就可以使用到索引排序</li>
</ul>
<h3 id="重复索引与冗余索引"><a href="#重复索引与冗余索引" class="headerlink" title="重复索引与冗余索引"></a>重复索引与冗余索引</h3><ul>
<li>重复索引: 是指 在同1个列(如age), 或者 顺序相同的几个列(age,school), 建立了多个索引,称为重复索引,重复索引没有任何帮助,只会增大索引文件,拖慢更新速度, 去掉.</li>
<li>冗余索引:是指2个索引所覆盖的列有重叠, 称为冗余索引比如x,m,列,加索引 <code>index x(x),index xm(x,m)x,xm</code>索引,两者的x列重叠了,这种情况,称为冗余索引.</li>
<li>甚至可以把<code>index mx(m,x)</code>索引也建立,mx,xm也不是重复的,因为列的顺序不一样.</li>
</ul>
<h3 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h3><ul>
<li>索引可以让查询锁定更少的行,Innodb在访问行的时候对其加锁，而索引可以减少Innodb访问的行数,从而减少锁的数量</li>
</ul>
<h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="优化数据库访问"><a href="#优化数据库访问" class="headerlink" title="优化数据库访问"></a>优化数据库访问</h3><ul>
<li>确认程序是否在检索大量超过需要的数据</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行</li>
<li>是否查询不需要的记录，常见的错误是误认为MySQL只会返回需要的数据，实际上mysql先是返回全部数据，在进行计算。一般使用limit区分</li>
<li>多表关联的时候返回了全部的列，只需要取出所用的列即可</li>
<li>优化select *操作,以及重复查询同一条数据行做好缓存</li>
<li>执行语句分析，检查MySQL是否扫描了额外的记录</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><ul>
<li>设计查询语句时，是否要将一个复杂的查询拆分成多个简单的查询</li>
<li>切分查询：将大查询切分成小查询，每个查询功能完全一样，但是只完成一部分数据的操作，每次返回一小部分的结果。比如在做定时清除线日志表大表数据删除时，分批次删除比较高效，可以大大减少删除时锁的持有时间</li>
<li>分解关联查询:可以对每一个表进行一次单表查询，然后将结果在程序中就行关联汇总。查询拆分后,执行单个查询可以减少锁的竞争。可以让缓存的效率更高，许多应用可以方便缓存单表查询对应的结果对象。</li>
</ul>
<h3 id="Mysql中驱动表的概念"><a href="#Mysql中驱动表的概念" class="headerlink" title="Mysql中驱动表的概念"></a>Mysql中驱动表的概念</h3><ul>
<li>mysql中指定了连接条件时，满足查询条件的记录行数少的表为驱动表；如未指定查询条件，则扫描行数少的为驱动表。mysql优化器就是这么粗暴以小表驱动大表的方式来决定执行顺序的。</li>
<li>有时这种优化方式反而使表的查询效率变低，这个时候<code>STRAIGHT_JOIN</code>就排上用场了</li>
</ul>
<blockquote>
<p>比如如下测试的sql,Table1表的FilterID字段建了索引</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select t1.*</span><br><span class="line">from Table1 t1</span><br><span class="line">inner join Table2 t2</span><br><span class="line">on t1.CommonID = t2.CommonID</span><br><span class="line">where t1.FilterID = 1</span><br><span class="line"></span><br><span class="line">STRAIGHT_JOIN 方式改写驱动表</span><br><span class="line"></span><br><span class="line">select t1.*</span><br><span class="line">from Table1 t1</span><br><span class="line">STRAIGHT_JOIN  Table2 t2</span><br><span class="line">on t1.CommonID = t2.CommonID</span><br><span class="line">where t1.FilterID = 1</span><br></pre></td></tr></table></figure>

<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><ul>
<li>当MySQL不能通过索引生成排序结果时，MySQL就需要自己排序，如果数据量少则在内存中进行，如果数据量大则使用磁盘，这个过程统一称为文件排序</li>
<li>排序的数据量小于排序缓冲区，则使用内存进行快速排序操作。如果内存不够，会先将数据分块，对每个独立的块进行排序,并将各个块的排序结果放在磁盘上，最后将各个排序好的块进行合并返回结果</li>
<li>mysql在新版本中使用单次排序算法，先读取查询所需要的所有列，然后在根据给定的列进行排序，最后直接返回排序结果。</li>
</ul>
<h3 id="优化COUNT查询"><a href="#优化COUNT查询" class="headerlink" title="优化COUNT查询"></a>优化COUNT查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 改查询需要扫描474条行数</span><br><span class="line">EXPLAIN select count(*)  from  system_log20190401000001 where id &gt;5;</span><br><span class="line"></span><br><span class="line"># 将条件反转一下，先查询id&lt;5的数据，然后利用总数去做减法也能得到结果 </span><br><span class="line">EXPLAIN select (select count(*)  from  system_log20190401000001)-count(*) from system_log20190401000001  where id &lt;=5;</span><br></pre></td></tr></table></figure>

<h3 id="优化limit分页"><a href="#优化limit分页" class="headerlink" title="优化limit分页"></a>优化limit分页</h3><ul>
<li>在做limit分页时通常使用偏移量加排序的方式实现，但是当偏移量非常大的时候性能非常低下，比如取10020条只返回最后20条，前10000条都抛弃了，一般这种方面优化，要吗在页面上做大分页数限制，要吗优化大偏移量的性能。</li>
<li>优化此类分页查询的最简单办法就是利用覆盖索返回需要的列，防止回表操作。然后利用返回的数据做一次关联返回所需要的其余列。</li>
<li>有时也可以将limit查询转为为已知的位置进行查询，比如betwen 10000 and 10020</li>
<li>另一种做法就是缓存1000条数据，每次分页从缓存中取，大于1000就在页面额外设计按钮找到更多数据。</li>
</ul>
<h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h3><ul>
<li>UNION 操作符用于合并两个或多个SELECT语句的结果集</li>
<li>默认地，UNION操作符选取不同的值。如果允许重复的值，请使用 UNION ALL<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br><span class="line"></span><br><span class="line"><span class="comment"># UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/sql/" rel="tag"># sql</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/spring系列/SpringBoot集成ShardingJDBC实现分库分表/" rel="next" title="SpringBoot集成Sharding-JDBC实现分库分表">
                <i class="fa fa-chevron-left"></i> SpringBoot集成Sharding-JDBC实现分库分表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/20/golang/Day01/" rel="prev" title="【从零开始学Go】使用goquery爬取全网VIP影视资源在线观看地址">
                【从零开始学Go】使用goquery爬取全网VIP影视资源在线观看地址 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/logo_qinxuewu.jpg" alt="qinxuewu">
            
              <p class="site-author-name" itemprop="name">qinxuewu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qinxuewu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/qinxuewu" target="_blank" title="码云">
                      
                        <i class="fa fa-fw fa-google"></i>码云</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:870439570@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/spring-projects/spring-framework" title="spring" target="_blank">spring</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba" title="SpringCloudAlibaba" target="_blank">SpringCloudAlibaba</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://spring.io/projects/spring-cloud" title="SpringCloud" target="_blank">SpringCloud</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://spring.io/projects/spring-boot/" title="SpringBoot" target="_blank">SpringBoot</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL锁的粒度"><span class="nav-number">1.</span> <span class="nav-text">MySQL锁的粒度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表锁-table-lock"><span class="nav-number">1.1.</span> <span class="nav-text">表锁(table lock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行级锁-row-lock"><span class="nav-number">1.2.</span> <span class="nav-text">行级锁(row lock)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL的事务"><span class="nav-number">2.</span> <span class="nav-text">MySQL的事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务特性"><span class="nav-number">2.1.</span> <span class="nav-text">事务特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的隔离级别"><span class="nav-number">3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL中的事务"><span class="nav-number">3.1.</span> <span class="nav-text">MySQL中的事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多版本并发控制MVCC"><span class="nav-number">4.</span> <span class="nav-text">多版本并发控制MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库存储引擎"><span class="nav-number">5.</span> <span class="nav-text">数据库存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnDB存储引擎"><span class="nav-number">5.1.</span> <span class="nav-text">InnDB存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM引擎"><span class="nav-number">5.2.</span> <span class="nav-text">MyISAM引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Archive引擎"><span class="nav-number">5.3.</span> <span class="nav-text">Archive引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blackhole引擎"><span class="nav-number">5.4.</span> <span class="nav-text">Blackhole引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSV引擎"><span class="nav-number">5.5.</span> <span class="nav-text">CSV引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Federated引擎"><span class="nav-number">5.6.</span> <span class="nav-text">Federated引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory引擎"><span class="nav-number">5.7.</span> <span class="nav-text">Memory引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Schema-数据库的组织和结构-与数据类型优化"><span class="nav-number">6.</span> <span class="nav-text">Schema(数据库的组织和结构)与数据类型优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更小的通常好"><span class="nav-number">6.1.</span> <span class="nav-text">更小的通常好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单就好"><span class="nav-number">6.2.</span> <span class="nav-text">简单就好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量避免NUll"><span class="nav-number">6.3.</span> <span class="nav-text">尽量避免NUll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datetime和timesamp"><span class="nav-number">6.4.</span> <span class="nav-text">datetime和timesamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段列的类型选择"><span class="nav-number">6.5.</span> <span class="nav-text">字段列的类型选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用inet-aton和inet-ntoa处理ip地址数据"><span class="nav-number">6.6.</span> <span class="nav-text">使用inet_aton和inet_ntoa处理ip地址数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建高性能的索引"><span class="nav-number">7.</span> <span class="nav-text">创建高性能的索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引基础"><span class="nav-number">7.1.</span> <span class="nav-text">索引基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的选择策略"><span class="nav-number">7.2.</span> <span class="nav-text">索引的选择策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inndb主键索引和非主键索引的区别"><span class="nav-number">7.3.</span> <span class="nav-text">Inndb主键索引和非主键索引的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引覆盖"><span class="nav-number">7.4.</span> <span class="nav-text">索引覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理想的索引"><span class="nav-number">7.5.</span> <span class="nav-text">理想的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用索引扫描来做排序"><span class="nav-number">7.6.</span> <span class="nav-text">使用索引扫描来做排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复索引与冗余索引"><span class="nav-number">7.7.</span> <span class="nav-text">重复索引与冗余索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引和锁"><span class="nav-number">7.8.</span> <span class="nav-text">索引和锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询性能优化"><span class="nav-number">8.</span> <span class="nav-text">查询性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化数据库访问"><span class="nav-number">8.1.</span> <span class="nav-text">优化数据库访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构查询的方式"><span class="nav-number">8.2.</span> <span class="nav-text">重构查询的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql中驱动表的概念"><span class="nav-number">8.3.</span> <span class="nav-text">Mysql中驱动表的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序优化"><span class="nav-number">8.4.</span> <span class="nav-text">排序优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化COUNT查询"><span class="nav-number">8.5.</span> <span class="nav-text">优化COUNT查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化limit分页"><span class="nav-number">8.6.</span> <span class="nav-text">优化limit分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化UNION查询"><span class="nav-number">8.7.</span> <span class="nav-text">优化UNION查询</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qinxuewu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







  <div class="footer-custom">Hosted by <a target="_blank" href="https://github.com/qinxuewu">GitHub </a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
